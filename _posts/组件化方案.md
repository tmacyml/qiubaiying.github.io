
---
layout:     post
title:      组件化方案
subtitle:   iOS组件化尝试
date:       2018-3-13
author:     BY
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
- iOS
- 开发技巧
- Debug
---

####组件化方案
##### 1. 组件结构层次

1. Base层：三方依赖，以及基础通用组件库
2. Core层：网络请求，日志上报，推送，支付，下载，播放
3. Feature层：具体业务层模块
	
![Alt text](./1519552292931.png)

业务组件最上层就是我们app的壳工程，理想情况下是当我们把所有业务组件都抽离出来，壳工程会是一个很干净的，没有业务代码的工程。

##### 2.具体实现

具体到实现模块采用`cocoapods`管理，上层可以对下层模块`直接依赖`。feature也可以直接对基础组件依赖。不能出现组件之间存在横向依赖。

##### 3.组件间通信方案

### 组件化主流方案

+ **url路由方案**

![Alt text](./1843940-486b8887399a9f3a.jpg)

+ **target-action方案**
![Alt text](./270478-00fb1f35705bb080.png)

+ **protocol方案**

![Alt text](./mgj.jpg)


### 方案优劣

![Alt text](./270478-c757fbb88589211b.png)

​	上述提到的三种组件化方案，都采取中间件的方式。各个组件都依赖这个中间件，并通过该中间件进行通信。其中`url方案`与`action-target方案`都可以做到**中间件不依赖组件**，但是`url方案`需要在中间件中维护一个组件-服务的映射表，并且每个组件初始化时需要向中间件注册服务，而action-target方案则不需要维护映射表及服务注册。所以，应用内的组件通信，**对比url方案及action-target方案，采用action-target更为简洁高效**。

​	但是`action-target方案`及`url方案`**都需要维护一份文档**，因为这两个方案都是使用非模型化的传参方案，参数只能以字典等基本类型传递。使用字典类型就不能做到**参数类型检查**、**代码补全**、**参数限制**等功能，并且不同组件间参数的序列化及反序列化频繁，**编码效率及可维护性较差**。`protocol方案`则是可以解决组件间参数传递的这些问题。但`protocol方案`的中间件依赖每个组件提供的protocol协议，所以一旦任何一个组件的接口发生变动（新增或修改），都必须修改这个中间件。

**总的来说，现有的组件化方案，其实就以中间件的形式，在组件的外部对其进行规范。** 所以说真的要做到完全横向无依赖在理论上也是有矛盾的。所以在实践中应该已可维护性以及通用性的原则来选择适合自己的方案。
